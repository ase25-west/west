;;
;; Contexts
;;

;; Internal types

syntax init hint(desc "initialization status") =
  | SET | UNSET

syntax localtype hint(desc "local type") =
  init valtype

syntax instrtype hint(desc "instruction type") =
  resulttype ->_ localidx* resulttype  hint(macro "to")

var lct : localtype  hint(show lt)
var it : instrtype


;; Contexts

syntax context hint(desc "context") hint(macro "%" "C%") =
  { TYPES deftype*,
    RECS subtype*,
    FUNCS deftype*,
    GLOBALS globaltype*,
    TABLES tabletype*,
    MEMS memtype*,
    TAGS tagtype*,
    ELEMS elemtype*,
    DATAS datatype*,
    LOCALS localtype*,
    LABELS resulttype*,
    RETURN resulttype?,
    REFS funcidx*
  }

var C : context


;; Context update

;; TODO(3, rossberg): is there a way to show this as %[.LOCAL[%]* = %*] ?
def $with_locals(context, localidx*, localtype*) : context  hint(show %[.LOCAL[%]=%])

def $with_locals(C, eps, eps) = C
def $with_locals(C, x_1 x*, lct_1 lct*) = $with_locals(C[.LOCALS[x_1] = lct_1], x*, lct*)


;; Type closure

def $clos_valtype(context, valtype) : valtype  hint(show $clos_(%,%)) hint(macro "clostype")
def $clos_deftype(context, deftype) : deftype  hint(show $clos_(%,%)) hint(macro "clostype")
def $clos_moduletype(context, moduletype) : moduletype  hint(show $clos_(%,%)) hint(macro "clostype")
def $clos_deftypes(deftype*) : deftype*        hint(show $clos*#((%))) hint(macro "clostype")

;; TODO(3, rossberg): enable inlining dt*
def $clos_valtype(C, t) = $subst_all_valtype(t, dt*) -- if dt* = $clos_deftypes(C.TYPES)
def $clos_deftype(C, dt) = $subst_all_deftype(dt, dt'*) -- if dt'* = $clos_deftypes(C.TYPES)
def $clos_moduletype(C, mmt) = $subst_all_moduletype(mmt, dt*) -- if dt* = $clos_deftypes(C.TYPES)

def $clos_deftypes(eps) = eps
def $clos_deftypes(dt* dt_n) = dt'* $subst_all_deftype(dt_n, dt'*)  -- if dt'* = $clos_deftypes(dt*)


;;
;; Types
;;

;; Value types

relation Numtype_ok: context |- numtype : OK    hint(name "K-num")  hint(macro "%numtype")
relation Vectype_ok: context |- vectype : OK    hint(name "K-vec")  hint(macro "%vectype")
relation Heaptype_ok: context |- heaptype : OK  hint(name "K-heap") hint(macro "%heaptype")
relation Reftype_ok: context |- reftype : OK    hint(name "K-ref")  hint(macro "%reftype")
relation Valtype_ok: context |- valtype : OK    hint(name "K-val")  hint(macro "%valtype")


rule Numtype_ok:
  C |- numtype : OK

rule Vectype_ok:
  C |- vectype : OK

rule Heaptype_ok/abs:
  C |- absheaptype : OK

rule Heaptype_ok/typeidx:
  C |- _IDX typeidx : OK
  -- if C.TYPES[typeidx] = dt

rule Heaptype_ok/rec:
  C |- REC i : OK
  -- if C.RECS[i] = st

rule Reftype_ok:
  C |- REF NULL? heaptype : OK
  -- Heaptype_ok: C |- heaptype : OK

rule Valtype_ok/num:
  C |- numtype : OK
  -- Numtype_ok: C |- numtype : OK

rule Valtype_ok/vec:
  C |- vectype : OK
  -- Vectype_ok: C |- vectype : OK

rule Valtype_ok/ref:
  C |- reftype : OK
  -- Reftype_ok: C |- reftype : OK

rule Valtype_ok/bot:
  C |- BOT : OK


;; Result & instruction types

relation Resulttype_ok: context |- resulttype : OK  hint(name "K-result") hint(macro "%resulttype")
relation Instrtype_ok: context |- instrtype : OK    hint(name "K-instr")  hint(macro "%instrtype")

rule Resulttype_ok:
  C |- t* : OK
  -- (Valtype_ok: C |- t : OK)*

rule Instrtype_ok:
  C |- t_1* ->_(x*) t_2* : OK
  -- Resulttype_ok: C |- t_1* : OK
  -- Resulttype_ok: C |- t_2* : OK
  -- (if C.LOCALS[x] = lct)*


;; Type definitions

syntax oktypeidx hint(show OK#((typeidx)))    = | OK typeidx      hint(show OK#(%))    hint(macro "%subtype")
syntax oktypeidxnat hint(show OK#(typeidx,n)) = | OK typeidx nat  hint(show OK#(%, %)) hint(macro "%subtypeext")

relation Packtype_ok: context |- packtype : OK          hint(name "K-pack")    hint(macro "%packtype")
relation Fieldtype_ok: context |- fieldtype : OK        hint(name "K-field")   hint(macro "%fieldtype")
relation Storagetype_ok: context |- storagetype : OK    hint(name "K-storage") hint(macro "%storagetype")
relation Comptype_ok: context |- comptype : OK          hint(name "K-comp")    hint(macro "%comptype")
relation Functype_ok: context |- functype : OK          hint(name "K-func")    hint(macro "%functype")
relation Subtype_ok: context |- subtype : oktypeidx     hint(name "K-sub")     hint(macro "%subtype")
relation Rectype_ok: context |- rectype : oktypeidx     hint(name "K-rect")    hint(macro "%rectype")
relation Subtype_ok2: context |- subtype : oktypeidxnat hint(name "K-sub2")    hint(macro "%subtypeext")
relation Rectype_ok2: context |- rectype : oktypeidxnat hint(name "K-rec2")    hint(macro "%rectypeext")
relation Deftype_ok: context |- deftype : OK            hint(name "K-def")     hint(macro "%deftype")

;; Forward declaration
relation Comptype_sub: context |- comptype <: comptype  hint(name "S-comp")    hint(macro "%comptypematch")
relation Deftype_sub: context |- deftype <: deftype     hint(name "S-def")     hint(macro "%deftypematch")


rule Packtype_ok:
  C |- packtype : OK

rule Storagetype_ok/val:
  C |- valtype : OK
  -- Valtype_ok: C |- valtype : OK

rule Storagetype_ok/pack:
  C |- packtype : OK
  -- Packtype_ok: C |- packtype : OK

rule Fieldtype_ok:
  C |- MUT? storagetype : OK
  -- Storagetype_ok: C |- storagetype : OK


rule Comptype_ok/struct:
  C |- STRUCT fieldtype* : OK
  -- (Fieldtype_ok: C |- fieldtype : OK)*

rule Comptype_ok/array:
  C |- ARRAY fieldtype : OK
  -- Fieldtype_ok: C |- fieldtype : OK

rule Comptype_ok/func:
  C |- FUNC functype : OK
  -- Functype_ok: C |- functype : OK


rule Subtype_ok:
  C |- SUB FINAL? (_IDX x)* comptype : OK(x_0)
  -- if |x*| <= 1
  -- (if x < x_0)*
  -- (if $unrolldt(C.TYPES[x]) = SUB (_IDX x')* comptype')*
  ----
  -- Comptype_ok: C |- comptype : OK
  -- (Comptype_sub: C |- comptype <: comptype')*

def $before(typeuse, typeidx, nat) : bool   hint(show % << %,%) hint(macro "before")
def $before(deftype, x, i) = true
def $before(_IDX typeidx, x, i) = typeidx < x
def $before(REC j, x, i) = j < i

def $unrollht(context, heaptype) : subtype  hint(show $unroll_(%,%))
def $unrollht(C, deftype) = $unrolldt(deftype)
def $unrollht(C, _IDX typeidx) = $unrolldt(C.TYPES[typeidx])
def $unrollht(C, REC i) = C.RECS[i]

rule Subtype_ok2:
  C |- SUB FINAL? typeuse* compttype : OK x i
  -- if |typeuse*| <= 1
  -- (if $before(typeuse, x, i))*
  -- (if $unrollht(C, typeuse) = SUB typeuse'* comptype')*
  ----
  -- Comptype_ok: C |- comptype : OK
  -- (Comptype_sub: C |- comptype <: comptype')*


rule Rectype_ok/empty:
  C |- REC eps : OK(x)

rule Rectype_ok/cons:
  C |- REC (subtype_1 subtype*) : OK(x)
  -- Subtype_ok: C |- subtype_1 : OK(x)
  -- Rectype_ok: C |- REC subtype* : OK($(x+1))

rule Rectype_ok/rec2:
  C |- REC subtype* : OK(x)
  -- Rectype_ok2: C, RECS subtype* |- REC subtype* : OK x 0

rule Rectype_ok2/empty:
  C |- REC eps : OK x i

rule Rectype_ok2/cons:
  C |- REC (subtype_1 subtype*) : OK x i
  -- Subtype_ok2: C |- subtype_1 : OK x i
  -- Rectype_ok2: C |- REC subtype* : OK $(x+1) $(i+1)


rule Deftype_ok:
  C |- DEF rectype i : OK
  -- Rectype_ok: C |- rectype : OK(x)
  -- if rectype = REC subtype^n
  -- if i < n


;; External types

relation Limits_ok: context |- limits : nat         hint(name "K-limits") hint(macro "%limits")
relation Globaltype_ok: context |- globaltype : OK  hint(name "K-global") hint(macro "%globaltype")
relation Tabletype_ok: context |- tabletype : OK    hint(name "K-table")  hint(macro "%tabletype")
relation Memtype_ok: context |- memtype : OK        hint(name "K-mem")    hint(macro "%memtype")
relation Tagtype_ok: context |- tagtype : OK        hint(name "K-tag")    hint(macro "%tagtype")
relation Externtype_ok: context |- externtype : OK  hint(name "K-extern") hint(macro "%externtype")


rule Limits_ok:
  C |- `[n .. m] : k
  -- if n <= m <= k

rule Functype_ok:
  C |- t_1* -> t_2* : OK
  -- Resulttype_ok: C |- t_1* : OK
  -- Resulttype_ok: C |- t_2* : OK

rule Globaltype_ok:
  C |- MUT? t : OK
  -- Valtype_ok: C |- t : OK

rule Tabletype_ok:
  C |- addrtype limits reftype : OK
  -- Limits_ok: C |- limits : $(2^32 - 1)
  -- Reftype_ok: C |- reftype : OK

rule Memtype_ok:
  C |- addrtype limits PAGE : OK
  -- Limits_ok: C |- limits : $(2^16)

rule Tagtype_ok:
  C |- deftype : OK
  -- Deftype_ok: C |- deftype : OK
  -- Expand: deftype ~~ FUNC functype


rule Externtype_ok/func:
  C |- FUNC deftype : OK
  -- Deftype_ok: C |- deftype : OK
  -- Expand: deftype ~~ FUNC functype

rule Externtype_ok/global:
  C |- GLOBAL globaltype : OK
  -- Globaltype_ok: C |- globaltype : OK

rule Externtype_ok/table:
  C |- TABLE tabletype : OK
  -- Tabletype_ok: C |- tabletype : OK

rule Externtype_ok/mem:
  C |- MEM memtype : OK
  -- Memtype_ok: C |- memtype : OK

rule Externtype_ok/tag:
  C |- TAG tagtype : OK
  -- Tagtype_ok: C |- tagtype : OK



;;
;; Subtyping
;;

;; Value types

relation Numtype_sub: context |- numtype <: numtype    hint(name "S-num")  hint(macro "%numtypematch")
relation Vectype_sub: context |- vectype <: vectype    hint(name "S-vec")  hint(macro "%vectypematch")
relation Heaptype_sub: context |- heaptype <: heaptype hint(name "S-heap") hint(macro "%heaptypematch")
relation Reftype_sub: context |- reftype <: reftype    hint(name "S-ref")  hint(macro "%reftypematch")
relation Valtype_sub: context |- valtype <: valtype    hint(name "S-val")  hint(macro "%valtypematch")

rule Numtype_sub:
  C |- numtype <: numtype

rule Vectype_sub:
  C |- vectype <: vectype


rule Heaptype_sub/refl:
  C |- heaptype <: heaptype

rule Heaptype_sub/trans:
  C |- heaptype_1 <: heaptype_2
  -- Heaptype_ok: C |- heaptype' : OK
  -- Heaptype_sub: C |- heaptype_1 <: heaptype'
  -- Heaptype_sub: C |- heaptype' <: heaptype_2

;; Hardcoded trans-rules
rule Heaptype_sub/trans-eq:
  C |- heaptype_1 <: heaptype_2
  -- Heaptype_sub: C |- heaptype_1 <: EQ
  -- Heaptype_sub: C |- EQ <: heaptype_2
rule Heaptype_sub/trans-struct:
  C |- heaptype_1 <: heaptype_2
  -- Heaptype_sub: C |- heaptype_1 <: STRUCT
  -- Heaptype_sub: C |- STRUCT <: heaptype_2
rule Heaptype_sub/trans-array:
  C |- heaptype_1 <: heaptype_2
  -- Heaptype_sub: C |- heaptype_1 <: ARRAY
  -- Heaptype_sub: C |- ARRAY <: heaptype_2

rule Heaptype_sub/eq-any:
  C |- EQ <: ANY

rule Heaptype_sub/i31-eq:
  C |- I31 <: EQ

rule Heaptype_sub/struct-eq:
  C |- STRUCT <: EQ

rule Heaptype_sub/array-eq:
  C |- ARRAY <: EQ

rule Heaptype_sub/struct:
  C |- deftype <: STRUCT
  -- Expand: deftype ~~ STRUCT fieldtype*

rule Heaptype_sub/array:
  C |- deftype <: ARRAY
  -- Expand: deftype ~~ ARRAY fieldtype

rule Heaptype_sub/func:
  C |- deftype <: FUNC
  -- Expand: deftype ~~ FUNC functype

rule Heaptype_sub/def:
  C |- deftype_1 <: deftype_2
  -- Deftype_sub: C |- deftype_1 <: deftype_2

rule Heaptype_sub/typeidx-l:
  C |- _IDX typeidx <: heaptype
  -- Heaptype_sub: C |- C.TYPES[typeidx] <: heaptype

rule Heaptype_sub/typeidx-r:
  C |- heaptype <: _IDX typeidx
  -- Heaptype_sub: C |- heaptype <: C.TYPES[typeidx]

rule Heaptype_sub/rec:
  C |- REC i <: typeuse*[j]
  -- if C.RECS[i] = SUB fin typeuse* ct

rule Heaptype_sub/none:
  C |- NONE <: heaptype
  -- Heaptype_sub: C |- heaptype <: ANY

rule Heaptype_sub/nofunc:
  C |- NOFUNC <: heaptype
  -- Heaptype_sub: C |- heaptype <: FUNC

rule Heaptype_sub/noextern:
  C |- NOEXTERN <: heaptype
  -- Heaptype_sub: C |- heaptype <: EXTERN

rule Heaptype_sub/bot:
  C |- BOT <: heaptype


rule Reftype_sub/nonnull:
  C |- REF ht_1 <: REF ht_2
  -- Heaptype_sub: C |- ht_1 <: ht_2

rule Reftype_sub/null:
  C |- REF NULL? ht_1 <: REF NULL ht_2
  -- Heaptype_sub: C |- ht_1 <: ht_2


rule Valtype_sub/num:
  C |- numtype_1 <: numtype_2
  -- Numtype_sub: C |- numtype_1 <: numtype_2

rule Valtype_sub/vec:
  C |- vectype_1 <: vectype_2
  -- Vectype_sub: C |- vectype_1 <: vectype_2

rule Valtype_sub/ref:
  C |- reftype_1 <: reftype_2
  -- Reftype_sub: C |- reftype_1 <: reftype_2

rule Valtype_sub/bot:
  C |- BOT <: valtype


;; Result & instruction types

relation Resulttype_sub: context |- valtype* <: valtype*   hint(name "S-result") hint(macro "%resulttypematch")
relation Instrtype_sub: context |- instrtype <: instrtype  hint(name "S-instr")  hint(macro "%instrtypematch")

rule Resulttype_sub:
  C |- t_1* <: t_2*
  -- (Valtype_sub: C |- t_1 <: t_2)*

rule Instrtype_sub:
  C |- t_11* ->_(x_1*) t_12* <: t_21* ->_(x_2*) t_22*
  -- Resulttype_sub: C |- t_21* <: t_11*
  -- Resulttype_sub: C |- t_12* <: t_22*
  -- if x* = $setminus_(localidx, x_2*, x_1*)
  -- (if C.LOCALS[x] = SET t)*


;; Type definitions

relation Packtype_sub: context |- packtype <: packtype          hint(name "S-pack")    hint(macro "%packtypematch")
relation Storagetype_sub: context |- storagetype <: storagetype hint(name "S-storage") hint(macro "%storagetypematch")
relation Fieldtype_sub: context |- fieldtype <: fieldtype       hint(name "S-field")   hint(macro "%fieldtypematch")
relation Functype_sub: context |- functype <: functype          hint(name "S-func")    hint(macro "%functypematch")

;; Forward declared above
;;relation Comptype_sub: context |- comptype <: comptype        hint(name "S-comp")    hint(macro "%comptypematch")
;;relation Deftype_sub: context |- deftype <: deftype           hint(name "S-def")     hint(macro "%deftypematch")


rule Packtype_sub:
  C |- packtype <: packtype


rule Storagetype_sub/val:
  C |- valtype_1 <: valtype_2
  -- Valtype_sub: C |- valtype_1 <: valtype_2

rule Storagetype_sub/pack:
  C |- packtype_1 <: packtype_2
  -- Packtype_sub: C |- packtype_1 <: packtype_2


rule Fieldtype_sub/const:
  C |- zt_1 <: zt_2
  -- Storagetype_sub: C |- zt_1 <: zt_2

rule Fieldtype_sub/var:
  C |- MUT zt_1 <: MUT zt_2
  -- Storagetype_sub: C |- zt_1 <: zt_2
  -- Storagetype_sub: C |- zt_2 <: zt_1


rule Comptype_sub/struct:
  C |- STRUCT (yt_1* yt'_1) <: STRUCT yt_2*
  -- (Fieldtype_sub: C |- yt_1 <: yt_2)*

rule Comptype_sub/array:
  C |- ARRAY yt_1 <: ARRAY yt_2
  -- Fieldtype_sub: C |- yt_1 <: yt_2

rule Comptype_sub/func:
  C |- FUNC ft_1 <: FUNC ft_2
  -- Functype_sub: C |- ft_1 <: ft_2


rule Deftype_sub/refl:
  C |- deftype_1 <: deftype_2
  -- if $clos_deftype(C, deftype_1) = $clos_deftype(C, deftype_2)

rule Deftype_sub/super:
  C |- deftype_1 <: deftype_2
  -- if $unrolldt(deftype_1) = SUB fin typeuse* ct
  -- Heaptype_sub: C |- typeuse*[i] <: deftype_2


;; External types

relation Limits_sub: context |- limits <: limits             hint(name "S-limits") hint(macro "%limitsmatch")
relation Globaltype_sub: context |- globaltype <: globaltype hint(name "S-global") hint(macro "%globaltypematch")
relation Tabletype_sub: context |- tabletype <: tabletype    hint(name "S-table")  hint(macro "%tabletypematch")
relation Memtype_sub: context |- memtype <: memtype          hint(name "S-mem")    hint(macro "%memtypematch")
relation Tagtype_sub: context |- tagtype <: tagtype          hint(name "S-tag")    hint(macro "%tagtypematch")
relation Externtype_sub: context |- externtype <: externtype hint(name "S-extern") hint(macro "%externtypematch")


rule Limits_sub:
  C |- `[n_1 .. m_1] <: `[n_2 .. m_2]
  -- if n_1 >= n_2
  -- if m_1 <= m_2

rule Functype_sub:
  C |- t_11* -> t_12* <: t_21* -> t_22*
  -- Resulttype_sub: C |- t_21* <: t_11*
  -- Resulttype_sub: C |- t_12* <: t_22*

rule Globaltype_sub/const:
  C |- valtype_1 <: valtype_2
  -- Valtype_sub: C |- valtype_1 <: valtype_2

rule Globaltype_sub/var:
  C |- MUT valtype_1 <: MUT valtype_2
  -- Valtype_sub: C |- valtype_1 <: valtype_2
  -- Valtype_sub: C |- valtype_2 <: valtype_1

rule Tabletype_sub:
  C |- addrtype limits_1 reftype_1 <: addrtype limits_2 reftype_2
  -- Limits_sub: C |- limits_1 <: limits_2
  -- Reftype_sub: C |- reftype_1 <: reftype_2
  -- Reftype_sub: C |- reftype_2 <: reftype_1

rule Memtype_sub:
  C |- addrtype limits_1 PAGE <: addrtype limits_2 PAGE
  -- Limits_sub: C |- limits_1 <: limits_2

rule Tagtype_sub:
  C |- deftype_1 <: deftype_2
  -- Deftype_sub: C |- deftype_1 <: deftype_2
  -- Deftype_sub: C |- deftype_2 <: deftype_1


rule Externtype_sub/func:
  C |- FUNC deftype_1 <: FUNC deftype_2
  -- Deftype_sub: C |- deftype_1 <: deftype_2

rule Externtype_sub/global:
  C |- GLOBAL globaltype_1 <: GLOBAL globaltype_2
  -- Globaltype_sub: C |- globaltype_1 <: globaltype_2

rule Externtype_sub/table:
  C |- TABLE tabletype_1 <: TABLE tabletype_2
  -- Tabletype_sub: C |- tabletype_1 <: tabletype_2

rule Externtype_sub/mem:
  C |- MEM memtype_1 <: MEM memtype_2
  -- Memtype_sub: C |- memtype_1 <: memtype_2

rule Externtype_sub/tag:
  C |- TAG tagtype_1 <: TAG tagtype_2
  -- Tagtype_sub: C |- tagtype_1 <: tagtype_2



;;
;; Instructions
;;

relation Instr_ok: context |- instr : instrtype     hint(name "T")        hint(macro "%instr")
relation Instrs_ok: context |- instr* : instrtype   hint(name "T-instr*") hint(macro "%instrs")
relation Expr_ok: context |- expr : resulttype      hint(name "T-expr")   hint(macro "%expr")

relation Defaultable: |- valtype DEFAULTABLE  hint(show $default_(%2) =/= eps)
  hint(prose "A :ref:`default value <default-val>` for value type %1 is defined")  ;; TODO(3, ?): avoid hardcoding reST

relation Nondefaultable: |- valtype NONDEFAULTABLE  hint(show $default_(%2) = eps)
  hint(prose "A :ref:`default value <default-val>` for value type %1 is not defined")  ;; TODO(3, ?): avoid hardcoding reST


;; Parametric instructions

rule Instr_ok/nop:
  C |- NOP : eps -> eps

rule Instr_ok/unreachable:
  C |- UNREACHABLE : t_1* -> t_2*
  -- Instrtype_ok: C |- t_1* -> t_2* : OK

rule Instr_ok/drop:
  C |- DROP : t -> eps
  -- Valtype_ok: C |- t : OK


rule Instr_ok/select-expl:
  C |- SELECT t : t t I32 -> t
  -- Valtype_ok: C |- t : OK

rule Instr_ok/select-impl:
  C |- SELECT : t t I32 -> t
  -- Valtype_ok: C |- t : OK
  -- Valtype_sub: C |- t <: t'
  -- if t' = numtype \/ t' = vectype


;; Block instructions

relation Blocktype_ok: context |- blocktype : instrtype hint(name "K-block") hint(macro "%blocktype")

rule Blocktype_ok/valtype:
  C |- _RESULT valtype? : eps -> valtype?
  -- (Valtype_ok: C |- valtype : OK)?

rule Blocktype_ok/typeidx:
  C |- _IDX typeidx : t_1* -> t_2*
  -- Expand: C.TYPES[typeidx] ~~ FUNC (t_1* -> t_2*)


rule Instr_ok/block:
  C |- BLOCK bt instr* : t_1* -> t_2*
  -- Blocktype_ok: C |- bt : t_1* -> t_2*
  -- Instrs_ok: {LABELS (t_2*)} ++ C |- instr* : t_1* ->_(x*) t_2*

rule Instr_ok/loop:
  C |- LOOP bt instr* : t_1* -> t_2*
  -- Blocktype_ok: C |- bt : t_1* -> t_2*
  -- Instrs_ok: {LABELS (t_1*)} ++ C |- instr* : t_1* ->_(x*) t_2*

rule Instr_ok/if:
  C |- IF bt instr_1* ELSE instr_2* : t_1* I32 -> t_2*
  -- Blocktype_ok: C |- bt : t_1* -> t_2*
  -- Instrs_ok: {LABELS (t_2*)} ++ C |- instr_1* : t_1* ->_(x_1*) t_2*
  -- Instrs_ok: {LABELS (t_2*)} ++ C |- instr_2* : t_1* ->_(x_2*) t_2*


;; Branch instructions

rule Instr_ok/br:
  C |- BR l : t_1* t* -> t_2*
  -- if C.LABELS[l] = t*
  -- Instrtype_ok: C |- t_1* -> t_2* : OK

rule Instr_ok/br_if:
  C |- BR_IF l : t* I32 -> t*
  -- if C.LABELS[l] = t*

rule Instr_ok/br_table:
  C |- BR_TABLE l* l' : t_1* t* I32 -> t_2*
  -- (Resulttype_sub: C |- t* <: C.LABELS[l])*
  -- Resulttype_sub: C |- t* <: C.LABELS[l']
  -- Instrtype_ok: C |- t_1* -> t_2* : OK

rule Instr_ok/br_on_null:
  C |- BR_ON_NULL l : t* (REF NULL ht) -> t* (REF ht)
  -- if C.LABELS[l] = t*
  -- Heaptype_ok: C |- ht : OK

rule Instr_ok/br_on_non_null:
  C |- BR_ON_NON_NULL l : t* (REF NULL ht) -> t*
  -- if C.LABELS[l] = t* (REF ht)

rule Instr_ok/br_on_cast:
  C |- BR_ON_CAST l rt_1 rt_2 : t* rt_1 -> t* ($diffrt(rt_1, rt_2))
  -- if C.LABELS[l] = t* rt
  -- Reftype_ok: C |- rt_1 : OK
  -- Reftype_ok: C |- rt_2 : OK
  -- Reftype_sub: C |- rt_2 <: rt_1
  -- Reftype_sub: C |- rt_2 <: rt

rule Instr_ok/br_on_cast_fail:
  C |- BR_ON_CAST_FAIL l rt_1 rt_2 : t* rt_1 -> t* rt_2
  -- if C.LABELS[l] = t* rt
  -- Reftype_ok: C |- rt_1 : OK
  -- Reftype_ok: C |- rt_2 : OK
  -- Reftype_sub: C |- rt_2 <: rt_1
  -- Reftype_sub: C |- $diffrt(rt_1, rt_2) <: rt


;; Function instructions

rule Instr_ok/call:
  C |- CALL x : t_1* -> t_2*
  -- Expand: C.FUNCS[x] ~~ FUNC (t_1* -> t_2*)

rule Instr_ok/call_ref:
  C |- CALL_REF (_IDX x) : t_1* (REF NULL (_IDX x)) -> t_2*
  -- Expand: C.TYPES[x] ~~ FUNC (t_1* -> t_2*)

rule Instr_ok/call_indirect:
  C |- CALL_INDIRECT x (_IDX y) : t_1* at -> t_2*
  -- if C.TABLES[x] = at lim rt
  -- Reftype_sub: C |- rt <: (REF NULL FUNC)
  -- Expand: C.TYPES[y] ~~ FUNC (t_1* -> t_2*)

rule Instr_ok/return:
  C |- RETURN : t_1* t* -> t_2*
  -- if C.RETURN = (t*)
  -- Instrtype_ok: C |- t_1* -> t_2* : OK

;; TODO(3, rossberg): enable t_2* <: C.RETURN
rule Instr_ok/return_call:
  C |- RETURN_CALL x : t_3* t_1* -> t_4*
  -- Expand: C.FUNCS[x] ~~ FUNC (t_1* -> t_2*)
  -- if C.RETURN = (t'_2*)
  -- Resulttype_sub: C |- t_2* <: t'_2*
  -- Instrtype_ok: C |- t_3* -> t_4* : OK

;; TODO(3, rossberg): enable t_2* <: C.RETURN
rule Instr_ok/return_call_ref:
  C |- RETURN_CALL_REF (_IDX x) : t_3* t_1* (REF NULL (_IDX x)) -> t_4*
  -- Expand: C.TYPES[x] ~~ FUNC (t_1* -> t_2*)
  -- if C.RETURN = (t'_2*)
  -- Resulttype_sub: C |- t_2* <: t'_2*
  -- Instrtype_ok: C |- t_3* -> t_4* : OK

;; TODO(3, rossberg): enable t_2* <: C.RETURN
rule Instr_ok/return_call_indirect:
  C |- RETURN_CALL_INDIRECT x (_IDX y) : t_3* t_1* at -> t_4*
  -- if C.TABLES[x] = at lim rt
  -- Reftype_sub: C |- rt <: (REF NULL FUNC)
  ----
  -- Expand: C.TYPES[y] ~~ FUNC (t_1* -> t_2*)
  -- if C.RETURN = (t'_2*)
  -- Resulttype_sub: C |- t_2* <: t'_2*
  -- Instrtype_ok: C |- t_3* -> t_4* : OK


;; Exception instructions

relation Catch_ok: context |- catch : OK hint(name "T") hint(macro "%catch")

rule Instr_ok/throw:
  C |- THROW x : t_1* t* -> t_2*
  -- Expand: C.TAGS[x] ~~ FUNC (t* -> eps)
  -- Instrtype_ok: C |- t_1* -> t_2* : OK

rule Instr_ok/throw_ref:
  C |- THROW_REF : t_1* (REF NULL EXN) -> t_2*
  -- Instrtype_ok: C |- t_1* -> t_2* : OK

rule Instr_ok/try_table:
  C |- TRY_TABLE bt catch* instr* : t_1* -> t_2*
  -- Blocktype_ok: C |- bt : t_1* -> t_2*
  -- Instrs_ok: {LABELS (t_2*)} ++ C |- instr* : t_1* ->_(x*) t_2*
  -- (Catch_ok: C |- catch : OK)*

rule Catch_ok/catch:
  C |- CATCH x l : OK
  -- Expand: C.TAGS[x] ~~ FUNC (t* -> eps)
  -- Resulttype_sub: C |- t* <: C.LABELS[l]

rule Catch_ok/catch_ref:
  C |- CATCH_REF x l : OK
  -- Expand: C.TAGS[x] ~~ FUNC (t* -> eps)
  -- Resulttype_sub: C |- t* (REF EXN) <: C.LABELS[l]

rule Catch_ok/catch_all:
  C |- CATCH_ALL l : OK
  -- Resulttype_sub: C |- eps <: C.LABELS[l]

rule Catch_ok/catch_all_ref:
  C |- CATCH_ALL_REF l : OK
  -- Resulttype_sub: C |- (REF EXN) <: C.LABELS[l]


;; Numeric instructions

rule Instr_ok/const:
  C |- CONST nt c_nt : eps -> nt

rule Instr_ok/unop:
  C |- UNOP nt unop_nt : nt -> nt

rule Instr_ok/binop:
  C |- BINOP nt binop_nt : nt nt -> nt

rule Instr_ok/testop:
  C |- TESTOP nt testop_nt : nt -> I32

rule Instr_ok/relop:
  C |- RELOP nt relop_nt : nt nt -> I32

rule Instr_ok/cvtop:
  C |- CVTOP nt_1 nt_2 cvtop : nt_2 -> nt_1


;; Reference instructions

rule Instr_ok/ref.null:
  C |- REF.NULL ht : eps -> (REF NULL ht)
  -- Heaptype_ok: C |- ht : OK

rule Instr_ok/ref.func:
  C |- REF.FUNC x : eps -> (REF dt)
  -- if C.FUNCS[x] = dt
  -- if x <- C.REFS

rule Instr_ok/ref.i31:
  C |- REF.I31 : I32 -> (REF I31)

rule Instr_ok/ref.is_null:
  C |- REF.IS_NULL : (REF NULL ht) -> I32
  -- Heaptype_ok: C |- ht : OK

rule Instr_ok/ref.as_non_null:
  C |- REF.AS_NON_NULL : (REF NULL ht) -> (REF ht)
  -- Heaptype_ok: C |- ht : OK

rule Instr_ok/ref.eq:
  C |- REF.EQ : (REF NULL EQ) (REF NULL EQ) -> I32

rule Instr_ok/ref.test:
  C |- REF.TEST rt : rt' -> I32
  -- Reftype_ok: C |- rt : OK
  -- Reftype_ok: C |- rt' : OK
  -- Reftype_sub: C |- rt <: rt'

rule Instr_ok/ref.cast:
  C |- REF.CAST rt : rt' -> rt
  -- Reftype_ok: C |- rt : OK
  -- Reftype_ok: C |- rt' : OK
  -- Reftype_sub: C |- rt <: rt'


;; Scalar reference instructions

rule Instr_ok/i31.get:
  C |- I31.GET sx : (REF NULL I31) -> I32


;; Structure instructions

rule Instr_ok/struct.new:
  C |- STRUCT.NEW x : $unpack(zt)* -> (REF (_IDX x))
  -- Expand: C.TYPES[x] ~~ STRUCT (mut zt)*

rule Instr_ok/struct.new_default:
  C |- STRUCT.NEW_DEFAULT x : eps -> (REF (_IDX x))
  -- Expand: C.TYPES[x] ~~ STRUCT (mut zt)*
  -- (Defaultable: |- $unpack(zt) DEFAULTABLE)*

rule Instr_ok/struct.get:
  C |- STRUCT.GET sx? x i : (REF NULL (_IDX x)) -> $unpack(zt)
  -- Expand: C.TYPES[x] ~~ STRUCT yt*
  -- if yt*[i] = mut zt
  -- if sx? = eps <=> zt = $unpack(zt)

rule Instr_ok/struct.set:
  C |- STRUCT.SET x i : (REF NULL (_IDX x)) $unpack(zt) -> eps
  -- Expand: C.TYPES[x] ~~ STRUCT yt*
  -- if yt*[i] = MUT zt


;; Array instructions

rule Instr_ok/array.new:
  C |- ARRAY.NEW x : $unpack(zt) I32 -> (REF (_IDX x))
  -- Expand: C.TYPES[x] ~~ ARRAY (mut zt)

rule Instr_ok/array.new_default:
  C |- ARRAY.NEW_DEFAULT x : I32 -> (REF (_IDX x))
  -- Expand: C.TYPES[x] ~~ ARRAY (mut zt)
  -- Defaultable: |- $unpack(zt) DEFAULTABLE

rule Instr_ok/array.new_fixed:
  C |- ARRAY.NEW_FIXED x n : $unpack(zt)^n -> (REF (_IDX x))
  -- Expand: C.TYPES[x] ~~ ARRAY (mut zt)

rule Instr_ok/array.new_elem:
  C |- ARRAY.NEW_ELEM x y : I32 I32 -> (REF (_IDX x))
  -- Expand: C.TYPES[x] ~~ ARRAY (mut rt)
  -- Reftype_sub: C |- C.ELEMS[y] <: rt

rule Instr_ok/array.new_data:
  C |- ARRAY.NEW_DATA x y : I32 I32 -> (REF (_IDX x))
  -- Expand: C.TYPES[x] ~~ ARRAY (mut zt)
  -- if $unpack(zt) = numtype \/ $unpack(zt) = vectype
  -- if C.DATAS[y] = OK

rule Instr_ok/array.get:
  C |- ARRAY.GET sx? x : (REF NULL (_IDX x)) I32 -> $unpack(zt)
  -- Expand: C.TYPES[x] ~~ ARRAY (mut zt)
  -- if sx? = eps <=> zt = $unpack(zt)

rule Instr_ok/array.set:
  C |- ARRAY.SET x : (REF NULL (_IDX x)) I32 $unpack(zt) -> eps
  -- Expand: C.TYPES[x] ~~ ARRAY (MUT zt)

rule Instr_ok/array.len:
  C |- ARRAY.LEN : (REF NULL ARRAY) -> I32

rule Instr_ok/array.fill:
  C |- ARRAY.FILL x : (REF NULL (_IDX x)) I32 $unpack(zt) I32 -> eps
  -- Expand: C.TYPES[x] ~~ ARRAY (MUT zt)

rule Instr_ok/array.copy:
  C |- ARRAY.COPY x_1 x_2 : (REF NULL (_IDX x_1)) I32 (REF NULL (_IDX x_2)) I32 I32 -> eps
  -- Expand: C.TYPES[x_1] ~~ ARRAY (MUT zt_1)
  -- Expand: C.TYPES[x_2] ~~ ARRAY (mut zt_2)
  -- Storagetype_sub: C |- zt_2 <: zt_1

rule Instr_ok/array.init_elem:
  C |- ARRAY.INIT_ELEM x y : (REF NULL (_IDX x)) I32 I32 I32 -> eps
  -- Expand: C.TYPES[x] ~~ ARRAY (MUT zt)
  -- Storagetype_sub: C |- C.ELEMS[y] <: zt

rule Instr_ok/array.init_data:
  C |- ARRAY.INIT_DATA x y : (REF NULL (_IDX x)) I32 I32 I32 -> eps
  -- Expand: C.TYPES[x] ~~ ARRAY (MUT zt)
  -- if $unpack(zt) = numtype \/ $unpack(zt) = vectype
  -- if C.DATAS[y] = OK


;; External reference instructions

rule Instr_ok/extern.convert_any:
  C |- EXTERN.CONVERT_ANY : (REF nul1 ANY) -> (REF nul2 EXTERN)
  -- if nul1 = nul2

rule Instr_ok/any.convert_extern:
  C |- ANY.CONVERT_EXTERN : (REF nul1 EXTERN) -> (REF nul2 ANY)
  -- if nul1 = nul2


;; Vector instructions

rule Instr_ok/vconst:
  C |- VCONST V128 c : eps -> V128

rule Instr_ok/vvunop:
  C |- VVUNOP V128 vvunop : V128 -> V128

rule Instr_ok/vvbinop:
  C |- VVBINOP V128 vvbinop : V128 V128 -> V128

rule Instr_ok/vvternop:
  C |- VVTERNOP V128 vvternop : V128 V128 V128 -> V128

rule Instr_ok/vvtestop:
  C |- VVTESTOP V128 vvtestop : V128 -> I32

rule Instr_ok/vunop:
  C |- VUNOP sh vunop : V128 -> V128

rule Instr_ok/vbinop:
  C |- VBINOP sh vbinop : V128 V128 -> V128

rule Instr_ok/vternop:
  C |- VTERNOP sh vternop : V128 V128 V128 -> V128

rule Instr_ok/vtestop:
  C |- VTESTOP sh vtestop : V128 -> I32

rule Instr_ok/vrelop:
  C |- VRELOP sh vrelop : V128 V128 -> V128

rule Instr_ok/vshiftop:
  C |- VSHIFTOP sh vshiftop : V128 I32 -> V128

rule Instr_ok/vbitmask:
  C |- VBITMASK sh : V128 -> I32

rule Instr_ok/vswizzlop:
  C |- VSWIZZLOP sh vswizzlop : V128 V128 -> V128

rule Instr_ok/vshuffle:
  C |- VSHUFFLE sh i* : V128 V128 -> V128
  -- (if $(i < 2*$dim(sh)))*

rule Instr_ok/vsplat:
  C |- VSPLAT sh : $unpackshape(sh) -> V128

rule Instr_ok/vextract_lane:
  C |- VEXTRACT_LANE sh sx? i : V128 -> $unpackshape(sh)
  -- if i < $dim(sh)

rule Instr_ok/vreplace_lane:
  C |- VREPLACE_LANE sh i : V128 $unpackshape(sh) -> V128
  -- if i < $dim(sh)

rule Instr_ok/vextunop:
  C |- VEXTUNOP sh_1 sh_2 vextunop : V128 -> V128

rule Instr_ok/vextbinop:
  C |- VEXTBINOP sh_1 sh_2 vextbinop : V128 V128 -> V128

rule Instr_ok/vextternop:
  C |- VEXTTERNOP sh_1 sh_2 vextternop : V128 V128 V128 -> V128

rule Instr_ok/vnarrow:
  C |- VNARROW sh_1 sh_2 sx : V128 V128 -> V128

rule Instr_ok/vcvtop:
  C |- VCVTOP sh_1 sh_2 vcvtop half? zero? : V128 -> V128


;; Local instructions

rule Instr_ok/local.get:
  C |- LOCAL.GET x : eps -> t
  -- if C.LOCALS[x] = SET t

rule Instr_ok/local.set:
  C |- LOCAL.SET x : t ->_(x) eps
  -- if C.LOCALS[x] = init t

rule Instr_ok/local.tee:
  C |- LOCAL.TEE x : t ->_(x) t
  -- if C.LOCALS[x] = init t


;; Global instructions

rule Instr_ok/global.get:
  C |- GLOBAL.GET x : eps -> t
  -- if C.GLOBALS[x] = mut t

rule Instr_ok/global.set:
  C |- GLOBAL.SET x : t -> eps
  -- if C.GLOBALS[x] = MUT t


;; Table instructions

rule Instr_ok/table.get:
  C |- TABLE.GET x : at -> rt
  -- if C.TABLES[x] = at lim rt

rule Instr_ok/table.set:
  C |- TABLE.SET x : at rt -> eps
  -- if C.TABLES[x] = at lim rt

rule Instr_ok/table.size:
  C |- TABLE.SIZE x : eps -> at
  -- if C.TABLES[x] = at lim rt

rule Instr_ok/table.grow:
  C |- TABLE.GROW x : rt at -> at
  -- if C.TABLES[x] = at lim rt

rule Instr_ok/table.fill:
  C |- TABLE.FILL x : at rt at -> eps
  -- if C.TABLES[x] = at lim rt

rule Instr_ok/table.copy:
  C |- TABLE.COPY x_1 x_2 : at_1 at_2 $minat(at_1, at_2) -> eps
  -- if C.TABLES[x_1] = at_1 lim_1 rt_1
  -- if C.TABLES[x_2] = at_2 lim_2 rt_2
  -- Reftype_sub: C |- rt_2 <: rt_1

rule Instr_ok/table.init:
  C |- TABLE.INIT x y : at I32 I32 -> eps
  -- if C.TABLES[x] = at lim rt_1
  -- if C.ELEMS[y] = rt_2
  -- Reftype_sub: C |- rt_2 <: rt_1

rule Instr_ok/elem.drop:
  C |- ELEM.DROP x : eps -> eps
  -- if C.ELEMS[x] = rt


;; Memory instructions

rule Instr_ok/memory.size:
  C |- MEMORY.SIZE x : eps -> at
  -- if C.MEMS[x] = at lim PAGE

rule Instr_ok/memory.grow:
  C |- MEMORY.GROW x : at -> at
  -- if C.MEMS[x] = at lim PAGE

rule Instr_ok/memory.fill:
  C |- MEMORY.FILL x : at I32 at -> eps
  -- if C.MEMS[x] = at lim PAGE

rule Instr_ok/memory.copy:
  C |- MEMORY.COPY x_1 x_2 : at_1 at_2 $minat(at_1, at_2) -> eps
  -- if C.MEMS[x_1] = at_1 lim_1 PAGE
  -- if C.MEMS[x_2] = at_2 lim_2 PAGE

rule Instr_ok/memory.init:
  C |- MEMORY.INIT x y : at I32 I32 -> eps
  -- if C.MEMS[x] = at lim PAGE
  -- if C.DATAS[y] = OK

rule Instr_ok/data.drop:
  C |- DATA.DROP x : eps -> eps
  -- if C.DATAS[x] = OK

(;
rule Instr_ok/load:
  C |- LOAD nt (N _ sx)? x memarg : at -> nt
  -- if C.MEMS[x] = at lim PAGE
  -- if $(2^(memarg.ALIGN) <= $size(nt)/8)
  -- if $(2^(memarg.ALIGN) <= N/8 < $size(nt)/8)?
  -- if N? = eps \/ nt = Inn
;)

rule Instr_ok/load-val:
  C |- LOAD nt x memarg : at -> nt
  -- if C.MEMS[x] = at lim PAGE
  -- if $(2^(memarg.ALIGN) <= $size(nt)/8)

rule Instr_ok/load-pack:
  C |- LOAD Inn (M _ sx) x memarg : at -> Inn
  -- if C.MEMS[x] = at lim PAGE
  -- if $(2^(memarg.ALIGN) <= M/8)

(;
rule Instr_ok/store:
  C |- STORE nt N? x memarg : at nt -> eps
  -- if C.MEMS[x] = at lim PAGE
  -- if $(2^(memarg.ALIGN) <= $size(nt)/8)
  -- if $(2^(memarg.ALIGN) <= N/8 < $size(nt)/8)?
  -- if N? = eps \/ nt = Inn
;)

rule Instr_ok/store-val:
  C |- STORE nt x memarg : at nt -> eps
  -- if C.MEMS[x] = at lim PAGE
  -- if $(2^(memarg.ALIGN) <= $size(nt)/8)

rule Instr_ok/store-pack:
  C |- STORE Inn M x memarg : at Inn -> eps
  -- if C.MEMS[x] = at lim PAGE
  -- if $(2^(memarg.ALIGN) <= M/8)

rule Instr_ok/vload-val:
  C |- VLOAD V128 x memarg : at -> V128
  -- if C.MEMS[x] = at lim PAGE
  -- if $(2^(memarg.ALIGN) <= $vsize(V128)/8)

rule Instr_ok/vload-pack:
  C |- VLOAD V128 (SHAPE M X N _ sx) x memarg : at -> V128
  -- if C.MEMS[x] = at lim PAGE
  -- if $(2^(memarg.ALIGN) <= M/8 * N)

rule Instr_ok/vload-splat:
  C |- VLOAD V128 (SPLAT N) x memarg : at -> V128
  -- if C.MEMS[x] = at lim PAGE
  -- if $(2^(memarg.ALIGN) <= N/8)

rule Instr_ok/vload-zero:
  C |- VLOAD V128 (ZERO N) x memarg : at -> V128
  -- if C.MEMS[x] = at lim PAGE
  -- if $(2^(memarg.ALIGN) <= N/8)

rule Instr_ok/vload_lane:
  C |- VLOAD_LANE V128 N x memarg i : at V128 -> V128
  -- if C.MEMS[x] = at lim PAGE
  -- if $(2^(memarg.ALIGN) <= N/8)
  -- if $(i < 128/N)

rule Instr_ok/vstore:
  C |- VSTORE V128 x memarg : at V128 -> eps
  -- if C.MEMS[x] = at lim PAGE
  -- if $(2^(memarg.ALIGN) <= $vsize(V128)/8)

rule Instr_ok/vstore_lane:
  C |- VSTORE_LANE V128 N x memarg i : at V128 -> eps
  -- if C.MEMS[x] = at lim PAGE
  -- if $(2^(memarg.ALIGN) <= N/8)
  -- if $(i < 128/N)


;; Instruction sequences

rule Instrs_ok/empty:
  C |- eps : eps -> eps

;; TODO(3, rossberg): enable x_1*#x_2* to avoid space
rule Instrs_ok/seq:
  C |- instr_1 instr_2* : t_1* ->_(x_1* x_2*) t_3*
  -- Instr_ok: C |- instr_1 : t_1* ->_(x_1*) t_2*
  -- (if C.LOCALS[x_1] = init t)*
  -- Instrs_ok: $with_locals(C, x_1*, (SET t)*) |- instr_2* : t_2* ->_(x_2*) t_3*

rule Instrs_ok/sub:
  C |- instr* : it'
  -- Instrs_ok: C |- instr* : it
  -- Instrtype_sub: C |- it <: it'
  -- Instrtype_ok: C |- it' : OK

;; TODO(3, rossberg): allow omitting parens
rule Instrs_ok/frame:
  C |- instr* : (t* t_1*) ->_(x*) (t* t_2*)
  -- Instrs_ok: C |- instr* : t_1* ->_(x*) t_2*
  -- Resulttype_ok: C |- t* : OK


;; Expressions

rule Expr_ok:
  C |- instr* : t*
  -- Instrs_ok: C |- instr* : eps ->_(eps) t*


;; Constant expressions

relation Instr_const: context |- instr CONST             hint(name "C-instr") hint(macro "%instrconst")
relation Expr_const: context |- expr CONST               hint(name "C-expr")  hint(macro "%exprconst")
relation Expr_ok_const: context |- expr : valtype CONST  hint(name "TC-expr") hint(macro "%exprokconst")

rule Instr_const/const:
  C |- (CONST nt c_nt) CONST

rule Instr_const/vconst:
  C |- (VCONST vt c_vt) CONST

rule Instr_const/ref.null:
  C |- (REF.NULL ht) CONST

rule Instr_const/ref.i31:
  C |- (REF.I31) CONST

rule Instr_const/ref.func:
  C |- (REF.FUNC x) CONST

rule Instr_const/struct.new:
  C |- (STRUCT.NEW x) CONST

rule Instr_const/struct.new_default:
  C |- (STRUCT.NEW_DEFAULT x) CONST

rule Instr_const/array.new:
  C |- (ARRAY.NEW x) CONST

rule Instr_const/array.new_default:
  C |- (ARRAY.NEW_DEFAULT x) CONST

rule Instr_const/array.new_fixed:
  C |- (ARRAY.NEW_FIXED x n) CONST

rule Instr_const/any.convert_extern:
  C |- (ANY.CONVERT_EXTERN) CONST

rule Instr_const/extern.convert_any:
  C |- (EXTERN.CONVERT_ANY) CONST

rule Instr_const/global.get:
  C |- (GLOBAL.GET x) CONST
  -- if C.GLOBALS[x] = t

rule Instr_const/binop:
  C |- (BINOP Inn binop) CONST
  -- if Inn <- I32 I64
  -- if binop <- ADD SUB MUL


rule Expr_const: C |- instr* CONST
  -- (Instr_const: C |- instr CONST)*


rule Expr_ok_const:
  C |- expr : t CONST
  -- Expr_ok: C |- expr : t
  -- Expr_const: C |- expr CONST


;;
;; Modules
;;

;; Definitions

relation Type_ok: context |- type : deftype*         hint(name "T-type")     hint(macro "%type")
relation Func_ok: context |- func : deftype          hint(name "T-func")     hint(macro "%func")
relation Local_ok: context |- local : localtype      hint(name "T-local")    hint(macro "%local")
relation Global_ok: context |- global : globaltype   hint(name "T-global")   hint(macro "%global")
relation Table_ok: context |- table : tabletype      hint(name "T-table")    hint(macro "%table")
relation Mem_ok: context |- mem : memtype            hint(name "T-mem")      hint(macro "%mem")
relation Tag_ok: context |- tag : tagtype            hint(name "T-tag")      hint(macro "%tag")
relation Elem_ok: context |- elem : elemtype         hint(name "T-elem")     hint(macro "%elem")
relation Data_ok: context |- data : datatype         hint(name "T-data")     hint(macro "%data")
relation Elemmode_ok: context |- elemmode : elemtype hint(name "T-elemmode") hint(macro "%elemmode")
relation Datamode_ok: context |- datamode : datatype hint(name "T-datamode") hint(macro "%datamode")
relation Start_ok: context |- start : OK             hint(name "T-start")    hint(macro "%start")

rule Type_ok:
  C |- TYPE rectype : dt*
  -- if x = |C.TYPES|
  -- if dt* = $rolldt(x, rectype)
  -- Rectype_ok: C ++ {TYPES dt*} |- rectype : OK(x)

rule Local_ok/set:
  C |- LOCAL t : SET t
  -- Defaultable: |- t DEFAULTABLE

rule Local_ok/unset:
  C |- LOCAL t : UNSET t
  -- Nondefaultable: |- t NONDEFAULTABLE

rule Func_ok:
  C |- FUNC x local* expr : C.TYPES[x]
  -- Expand: C.TYPES[x] ~~ FUNC (t_1* -> t_2*)
  -- (Local_ok: C |- local : lct)*
  -- Expr_ok: C ++ {LOCALS (SET t_1)* lct*, LABELS (t_2*), RETURN (t_2*)} |- expr : t_2*

rule Global_ok:
  C |- GLOBAL globaltype expr : globaltype
  -- Globaltype_ok: C |- gt : OK
  -- if globaltype = mut t
  -- Expr_ok_const: C |- expr : t CONST

rule Table_ok:
  C |- TABLE tabletype expr : tabletype
  -- Tabletype_ok: C |- tt : OK
  -- if tabletype = at lim rt
  -- Expr_ok_const: C |- expr : rt CONST

rule Mem_ok:
  C |- MEMORY memtype : memtype
  -- Memtype_ok: C |- memtype : OK

rule Tag_ok:
  C |- TAG x : C.TYPES[x]
  -- Expand: C.TYPES[x] ~~ FUNC (resulttype -> eps)

rule Elem_ok:
  C |- ELEM elemtype expr* elemmode : elemtype
  -- Reftype_ok: C |- elemtype : OK
  -- (Expr_ok_const: C |- expr : elemtype CONST)*
  -- Elemmode_ok: C |- elemmode : elemtype

rule Data_ok:
  C |- DATA b* datamode : OK
  -- Datamode_ok: C |- datamode : OK

rule Elemmode_ok/active:
  C |- ACTIVE x expr : rt
  -- if C.TABLES[x] = at lim rt'
  -- Reftype_sub: C |- rt <: rt'
  -- Expr_ok_const: C |- expr : at CONST

rule Elemmode_ok/passive:
  C |- PASSIVE : rt

rule Elemmode_ok/declare:
  C |- DECLARE : rt

rule Datamode_ok/active:
  C |- ACTIVE x expr : OK
  -- if C.MEMS[x] = at lim PAGE
  -- Expr_ok_const: C |- expr : at CONST

rule Datamode_ok/passive:
  C |- PASSIVE : OK

rule Start_ok:
  C |- START x : OK
  -- Expand: C.FUNCS[x] ~~ FUNC (eps -> eps)


;; Im/exports

relation Import_ok: context |- import : externtype        hint(name "T-import")    hint(macro "%import")
relation Export_ok: context |- export : name externtype   hint(name "T-export")    hint(macro "%export")
relation Externidx_ok: context |- externidx : externtype  hint(name "T-externidx") hint(macro "%externidx")

rule Import_ok:
  C |- IMPORT name_1 name_2 xt : xt
  -- Externtype_ok: C |- xt : OK

rule Export_ok:
  C |- EXPORT name externidx : name xt
  -- Externidx_ok: C |- externidx : xt


rule Externidx_ok/func:
  C |- FUNC x : FUNC dt
  -- if C.FUNCS[x] = dt

rule Externidx_ok/global:
  C |- GLOBAL x : GLOBAL gt
  -- if C.GLOBALS[x] = gt

rule Externidx_ok/table:
  C |- TABLE x : TABLE tt
  -- if C.TABLES[x] = tt

rule Externidx_ok/mem:
  C |- MEM x : MEM mt
  -- if C.MEMS[x] = mt

rule Externidx_ok/tag:
  C |- TAG x : TAG jt
  -- if C.TAGS[x] = jt


;; Modules

relation Module_ok: |- module : moduletype            hint(name "T-module")  hint(macro "%module")
relation Types_ok: context |- type* : deftype*        hint(name "T-types")   hint(macro "%types")
relation Globals_ok: context |- global* : globaltype* hint(name "T-globals") hint(macro "%globals")

;; HACK for notation
syntax nonfuncs = global* table* mem* elem* data*
def $funcidx_nonfuncs(nonfuncs) : funcidx*  hint(show $funcidx(%)) hint(macro "freefuncidx")
def $funcidx_nonfuncs(global* table* mem* elem* data*) = $funcidx_module(MODULE eps eps eps global* table* mem* eps elem* data* eps eps)

rule Module_ok:
  |- MODULE type* import* func* global* table* mem* tag* elem* data* start? export* : $clos_moduletype(C, xt_I* -> xt_E*)
  -- Types_ok: {} |- type* : dt'*
  -- (Import_ok: {TYPES dt'*} |- import : xt_I)*
  ----
  -- Globals_ok: C' |- global* : gt*
  -- (Table_ok: C' |- table : tt)*
  -- if |mem*| <= 1
  -- (Mem_ok: C' |- mem : mt)*
  -- (Tag_ok: C' |- tag : jt)*
  -- (Func_ok: C |- func : dt)*
  ----
  -- (Elem_ok: C |- elem : rt)*
  -- (Data_ok: C |- data : ok)*
  -- (Start_ok: C |- start : OK)?
  -- (Export_ok: C |- export : nm xt_E)*
  -- if $disjoint_(name, nm*)
  ----
  -- if C = C' ++ {GLOBALS gt*, TABLES tt_I* tt*, MEMS mt_I* mt*, TAGS jt_I* jt*, ELEMS rt*, DATAS ok*}
  ----
  -- if C' = {TYPES dt'*, FUNCS dt_I* dt*, GLOBALS gt_I*, REFS x*}
  -- if x* = $funcidx_nonfuncs(global* table* mem* elem* data*)
  ----
  -- if dt_I* = $funcsxt(xt_I*)
  -- if gt_I* = $globalsxt(xt_I*)
  -- if tt_I* = $tablesxt(xt_I*)
  -- if mt_I* = $memsxt(xt_I*)
  -- if jt_I* = $tagsxt(xt_I*)


rule Types_ok/empty:
  C |- eps : eps

rule Types_ok/cons:
  C |- type_1 type* : dt_1* dt*
  -- Type_ok: C |- type_1 : dt_1*
  -- Types_ok: C ++ {TYPES dt_1*} |- type* : dt*

rule Globals_ok/empty:
  C |- eps : eps

rule Globals_ok/cons:
  C |- global_1 global* : gt_1 gt*
  -- Global_ok: C |- global_1 : gt_1
  -- Globals_ok: C ++ {GLOBALS gt_1} |- global* : gt*
